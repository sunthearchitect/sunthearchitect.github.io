{"meta":{"title":"Sun's notepad","subtitle":"내 개발일지","description":"개발일지","author":"태양","url":"http://sunthearchitect.github.io"},"pages":[{"title":"About","date":"2018-03-26T14:19:00.988Z","updated":"2018-03-26T14:19:00.988Z","comments":true,"path":"about/index.html","permalink":"http://sunthearchitect.github.io/about/index.html","excerpt":"","text":"Sun is a boy."},{"title":"Categories","date":"2018-03-26T14:19:00.989Z","updated":"2018-03-26T14:19:00.989Z","comments":true,"path":"categories/index.html","permalink":"http://sunthearchitect.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-03-26T14:19:00.989Z","updated":"2018-03-26T14:19:00.989Z","comments":true,"path":"tags/index.html","permalink":"http://sunthearchitect.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"웹 서버 인증 기초","slug":"웹-서버-인증-기초","date":"2018-07-15T10:41:35.000Z","updated":"2018-07-15T12:55:02.817Z","comments":true,"path":"2018/07/15/웹-서버-인증-기초/","link":"","permalink":"http://sunthearchitect.github.io/2018/07/15/웹-서버-인증-기초/","excerpt":"","text":"웹서버는 기본적으로 문서를 전송하기 위해 만들어진 것이다. 하지만 웹서버를 통해 개인화된 문서를 전송하려는 요구사항이 생김에 따라 서버-클라이언트의 상태를 관리할 필요가 생겼고 이를 HTTP State Management라고 한다. 서버-클라이언트 간의 통신 시 클라이언트는 자신임을 입증하기 위한 정보를 서버에 송신하는데 이를 네트웍 상의 중간자가 관찰 및 탈취하여 재전송을 시도하게 되면 본인의 인증을 가로챌 수 있다. 이를 막기 위해 보안상의 여러가지 방법이 고안되었는데 HTTP 기본인증, 다이제스트 인증, 보안HTTP(HTTPS) 세가지가 있다. 이 중 현재 권장되는 방법은 HTTPS(RFC 2818)다.","categories":[],"tags":[{"name":"인증, 상호인증, nonce, 논스, 넌스","slug":"인증-상호인증-nonce-논스-넌스","permalink":"http://sunthearchitect.github.io/tags/인증-상호인증-nonce-논스-넌스/"}]},{"title":"Markdown 작성 예제","slug":"markdown예시","date":"2018-06-04T12:50:16.196Z","updated":"2018-06-04T12:50:16.196Z","comments":true,"path":"2018/06/04/markdown예시/","link":"","permalink":"http://sunthearchitect.github.io/2018/06/04/markdown예시/","excerpt":"","text":"마크 다운 작성에 대해서 알아본다. hexo에서 문서 작성의 기본은 다음을 참조한다. documentation 간략한 예시는 다음과 같다. Hexo Posting Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server -o More info: Server Generate static files1$ hexo generate More info: Generating Deply to remote sites1$ hexo deploy More info: Deployment Clean static files1$ hexo clean Syntax Hilights1String s = new String(\"HI\");: 1$ ps -ef | grep 'tomcat6' Links1$ google.com : [google](http://www.google.com) google.com : google","categories":[{"name":"blog","slug":"blog","permalink":"http://sunthearchitect.github.io/categories/blog/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://sunthearchitect.github.io/tags/markdown/"}]},{"title":"숫자표현","slug":"숫자표현","date":"2018-03-27T14:40:39.000Z","updated":"2018-03-28T10:47:13.111Z","comments":true,"path":"2018/03/27/숫자표현/","link":"","permalink":"http://sunthearchitect.github.io/2018/03/27/숫자표현/","excerpt":"","text":"대부분의 프로그램에서 수를 다루지만 특히 백엔드-서버 프로그램,그 중에서도 핀테크 영역에서는 숫자를 중요하게 다룬다.통상적인 컴퓨팅에서의 숫자 표기를 알아보자. 기본형의 크기(Java)boolean : 1 bytechar : 2 bytesbyte : 1 byteshort : 2 bytesint : 4 byteslong : 8 bytesfloat : 4 bytesdouble : 8 bytes OS, Language, CPU에 따라 다를 수 있지만 자바의 예를 들어본다. 용어정리MSB (Most Significant Byte) 최상위 바이트를 지칭LSB (Least Significant Byte) 최하위 바이트를 지칭 빅엔디안 (Big-end-ian) 0x1234 : 12 340x12345678 : 12 34 56 78 MSB 부터 저장하는 방식, 네트워크에서 전송될 때 상기 타입을 따른다. 네트워크 라우팅은 맨 앞 바이트에서 통신의 성격을 지정해 주는 식으로 개발 되었기 때문이다.많은 네트워크 프로토콜 및 파일 포맷들이 빅엔디안을 따른다.앞에서부터 차례대로 숫자를 저장하기 때문에 사람이 인식하기 쉽다(예:디버그)는 장점도 있다.주로 RISC cpu, unix 또는 Mac OS에서 사용된다. 리틀엔디안 (Little-end-ian) 0x1234 : 34 120x12345678 : 78 56 34 12 LSB 부터 저장하는 방식, 주로 x86(인텔), windows에서 사용된다.가산기를 구현할 때 앞에서부터 읽기 때문에 설계가 용이한 장점이 있으며0x12(4 bytes 정수타입)의 경우 12 00 00 00 이 되는데 지정된 크기만 필요할 경우 뒷부분의 불필요한 바이트를 읽는 수고를 덜 수 있다는 장점이 있다. 바이엔디안 (Bi-end-ian) ARM cpu의 경우 엔디안을 지정해서 사용 할 수 있다. 왜 상기 시스템에서 Byte 단위에 대해서 따지는지 궁금할 수 있다.그 이유는 대게의 메모리 접근은 byte단위로 이뤄지기 때문이다.bit 단위의 접근은 low level에서 이뤄지며 보통 아키텍쳐에 중립적이다. 상기 개념들이 의미를 가지는 경우는 주로 소켓 통신을 할 경우다.소켓 통신을 할 경우 보통 미들웨어등의 다양한 layer를 거치는 경우가 많은데, 다양한 이기종 시스템들의 경우 OS, 아키텍쳐, 언어 또는 legacy system등의 이유로타입이 다를 경우가 많다. 그럴 때 기본적인 개념을 숙지해두면 도움이 될 것이다.","categories":[{"name":"computing","slug":"computing","permalink":"http://sunthearchitect.github.io/categories/computing/"}],"tags":[{"name":"엔디안, 빅엔디안, 리틀엔디안","slug":"엔디안-빅엔디안-리틀엔디안","permalink":"http://sunthearchitect.github.io/tags/엔디안-빅엔디안-리틀엔디안/"}]},{"title":"대칭키 암호 실전 예제","slug":"대칭키-암호-실전-예제","date":"2018-03-08T08:37:51.000Z","updated":"2018-06-11T12:24:39.667Z","comments":true,"path":"2018/03/08/대칭키-암호-실전-예제/","link":"","permalink":"http://sunthearchitect.github.io/2018/03/08/대칭키-암호-실전-예제/","excerpt":"","text":"현재 널리 사용되는 암호화의 종류에는 크게 대칭키 암호, 비대칭 암호가 있다. 비대칭 암호는 공개키 암호로도 알려져있는데 추후 포스팅 하기로 하고 본 포스트에서는 대칭키 암호에 대해 정리해본다. 자바를 예로 들면 java.security 또는 javax.crypto 패키지에서 AES암호화를 지원한다. 일반적으로 자주 쓰이는 암호화를 정리하자면 다음과 같다. 암호화 알고리즘 : AES운영모드 : ECB 또는 CBCPADDING : PKCS5 또는 PKCS7ENCODING : BASE64 또는 HEXA String 운영모드CBC는 Initial Vector를 사용한다는 점이 특징이다.각 모드의 장단점,특징 보다는 사용법을 다룬다.","categories":[{"name":"암호화","slug":"암호화","permalink":"http://sunthearchitect.github.io/categories/암호화/"}],"tags":[{"name":"암호","slug":"암호","permalink":"http://sunthearchitect.github.io/tags/암호/"},{"name":"암호화","slug":"암호화","permalink":"http://sunthearchitect.github.io/tags/암호화/"},{"name":"대칭키","slug":"대칭키","permalink":"http://sunthearchitect.github.io/tags/대칭키/"},{"name":"AES","slug":"AES","permalink":"http://sunthearchitect.github.io/tags/AES/"},{"name":"SEED","slug":"SEED","permalink":"http://sunthearchitect.github.io/tags/SEED/"},{"name":"CBC","slug":"CBC","permalink":"http://sunthearchitect.github.io/tags/CBC/"},{"name":"ECB","slug":"ECB","permalink":"http://sunthearchitect.github.io/tags/ECB/"}]}]}